[
    {
        "name" : "HandGame",
        "demoURL": "https://google.com",
        "codeURL": "https://github.com/Gerpea/hand_game",
        "description": "A little game, made it to get my skills back after a rather long hiatus from web application development. In short it recognizes the hand gesture you show to the camera, and compares it to the one drawn on the picture. And if it's correct, it adds a point. You can also play in pairs where everyone will have their own gestures and their own points. DIn general, this is all about functionality. It is realized on a small server on NestJS and websockets. The application itself is written in NextJS. YOLOv8 model converted to ONNX format is used for gesture recognition model. It runs directly in the browser in a separate WebWorker. I think it's better to try the demo and see the code links you see below. <Here I will leave a diagram of the application architecture>. Recognition - written in python, and allows you to train a model to add gestures and then exporitize it into ONNX format. ONNX Models - model files for recognizing, further loaded into WebApp. WebApp - The main module of the application, here the interface is rendered and interaction with the server and models takes place. Recongition package - Interaction with models takes place through this package. I wrapped the use of onnxruntime-web into separate classes for convenience. And in the same package there is a web wrapper that runs the code of these classes. The package itself exports the hooks to use them in the application. WebWorker - This is where the recognition code is executed so it doesn't block the rendering of the application. NextJS - The application itself that uses the hooks from the recognition package. It also connects to the server to play the game over the network. Server - used to create a game session and save user's points, also allows two players to participate in one session. Stores data in RedisStorage. And transmits data to the client mainly via WebSocket, REST API is used to create the game and user."
    },
    {
        "name" : "TODO AI",
        "demoURL": "https://google.com",
        "codeURL": "https://github.com/Gerpea/todo-ai",
        "description": "Now I continue to realize it whenever the urge arises. Basic TODO is now available with drag-and-drop batches and adding tasks by voice. I plan to add deleting a card with a glance and possibly drag and drop, as well as authorization via face recognition and maybe fingerprint. <A small schematic architecture>. NextJS - Draws the interface and communicates with the server to store user data. NextJS Server - Stores user task data in SQLite. It has a simple RESTP API interface for interacting with tasks. It uses cookies to authorize the user, which it creates itself using a random identifier on the first request without authorization cookies. Cookies are stored for one day so that the next day or when you clear cookies in the browser. All tasks will be lost and a new user will be created."
    },
    {
        "name" : "PricePrediction",
        "demoURL": "",
        "codeURL": "",
        "description": "This project has completely moved away from frontend, although there are plans to implement a web interface, but it is not necessary for now. I use the knowledge I have gained over the last year in data analysis. And trying to predict the behavior of the price of crypto-assets in the near future. There are several servers on FastAPI using Celery for heavy tasks. I need one server for training, one for data preparation and one for prediction. I didn't come to this at once, at first I tried to create as few additional servers as possible, but my computer can't cope with all tasks at the same time. So I had to spread everything over different machines. But now it is relatively easy to scale. There is also a database server. And an S3 server for the files. <I'll leave a schematic of the program>. NGINX - used to provide a single interface for all servers. TrainServer - The server where model training takes place. Different models are used here, such as LSTM, GatedTransfomers, MLP, XGBoost. An ensemble of these models is also used, as it gives slightly better results than using them individually. After training, the data about the model is recorded in the database and the model itself is saved in the cloud. PrepareServer - This is where the data is received for processing before training and prediction. Various transformations are performed on them, and their metadata is written to the database and to the cloud. PredictionServer - Uses the models trained by TrainServer and the data at the output of PrepareServer to give the final result to the user. PosgreSQL - Database storing data necessary for training and prediction. S3 - Stores various models and metadata from input files."
    }
]